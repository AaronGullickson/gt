% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_color.R
\name{data_color}
\alias{data_color}
\title{Perform data cell colorization}
\usage{
data_color(
  data,
  columns = everything(),
  rows = everything(),
  direction = c("column", "row"),
  target_columns = NULL,
  method = c("auto", "numeric", "bin", "quantile", "factor"),
  palette = NULL,
  domain = NULL,
  bins = 8,
  levels = NULL,
  ordered = FALSE,
  na_color = NULL,
  alpha = NULL,
  reverse = FALSE,
  fn = NULL,
  apply_to = c("fill", "text"),
  autocolor_text = TRUE,
  contrast_algo = c("apca", "wcag"),
  colors = NULL
)
}
\arguments{
\item{data}{A table object that is created using the \code{\link[=gt]{gt()}} function.}

\item{columns, rows}{The columns and rows to which cell data color operations
are constrained.}

\item{direction}{Should the color computations be performed column-wise or
row-wise? By default this is set with the \code{"column"} keyword and colors
will be applied down columns. The alternative option with the \code{"row"}
keyword ensures that color mapping will work across rows.}

\item{target_columns}{For indirect column coloring treatments, we can supply
the columns that will receive the styling. The necessary preconditions are:
(1) we must use \code{direction = "column"}, and (2) the number of columns
specified/resolved here must match that of \code{columns}.}

\item{method}{A method for computing color based on the data within body
cells. Can be \code{"auto"} (the default), \code{"numeric"}, \code{"bin"}, \code{"quantile"},
or \code{"factor"}.}

\item{palette}{A vector of color names, the name of an \strong{RColorBrewer}
palette, the name of a \strong{viridis} palette, or a discrete palette
accessible from the \strong{paletteer} package using the \verb{<package>::<palette>}
syntax (e.g., \code{"wesanderson::IsleofDogs1"}. If providing a vector of colors
as a palette, each color value provided must either be a color name (in the
set of colors provided by \code{\link[grDevices:colors]{grDevices::colors()}}) or a hexadecimal string in
the form of \code{"#RRGGBB"} or \code{"#RRGGBBAA"}.}

\item{domain}{The possible values that can be mapped. For the \code{"numeric"} and
\code{"bin"} methods, this can be a numeric range specified with a length of two
vector. Representative numeric data is needed for the \code{"quantile"} method
and categorical data must be used for the \code{"factor"} method. If \code{NULL} (the
default value), the values in each column or row (depending on \code{direction})
value will represent the domain.}

\item{bins}{For \code{method = "bin"} this can either be a numeric vector of two
or more unique cut points, or, a single numeric value (greater than or
equal to \code{2}) giving the number of intervals into which the domain values
are to be cut. By default, this is \code{8}.}

\item{levels}{For \code{method = "factor"} this allows for an alternate way of
specifying levels. If anything is provided here then any value supplied to
\code{domain} will be ignored. This should be a character vector of unique
values.}

\item{ordered}{For \code{method = "factor"}, setting this to \code{TRUE} means that the
vector supplied to \code{domain} will be treated as being in the correct order
if that vector needs to be coerced to a factor. By default, this is
\code{FALSE}.}

\item{na_color}{The color to use for missing values. By default (with
\code{na_color = NULL}) gray, \code{"#808080"}, will be used.}

\item{alpha}{An optional, fixed alpha transparency value that will be applied
to all of the \code{colors} provided (regardless of whether a color palette was
directly supplied or generated through a color mapping function).}

\item{reverse}{Should the colors computed operate in reverse order?
If \code{TRUE} then colors that normally change from red to blue will change in
the opposite direction. By default, this is \code{FALSE}.}

\item{fn}{A color mapping function from the \strong{scales} package. The supported
color mapping functions are: \code{\link[scales:col_numeric]{scales::col_quantile()}}, \code{\link[scales:col_numeric]{scales::col_bin()}},
\code{\link[scales:col_numeric]{scales::col_numeric()}}, and \code{\link[scales:col_numeric]{scales::col_factor()}}.}

\item{apply_to}{Which style element should the colors be applied to? Options
include the cell background (the default, given as \code{"fill"}) or the cell
text (\code{"text"}).}

\item{autocolor_text}{An option to let \strong{gt} modify the coloring of text
within cells undergoing background coloring. This will result in better
text-to-background color contrast. By default, this is set to \code{TRUE}.}

\item{contrast_algo}{The color contrast algorithm to use when
\code{autocolor_text = TRUE}. By default this is \code{"apca"} (Accessible Perceptual
Contrast Algorithm) and the alternative to this is \code{"wcag"} (Web Content
Accessibility Guidelines).}

\item{colors}{Deprecated. Use the \code{fn} argument instead to provide a
\strong{scales}-based color-mapping function. If providing a palette, use the
\code{palette} argument.}
}
\value{
An object of class \code{gt_tbl}.
}
\description{
It's possible to add color to data cells according to their values with the
\code{data_color()} function. There is a multitude of ways to perform data cell
colorizing here:
\itemize{
\item targeting: we can constrain which columns and rows should receive the
colorization treatment (through the \code{columns} and \code{rows} arguments)
\item direction: ordinarily we perform coloring in a column-wise fashion but
there is the option to color data cells in a row-wise manner (this is
controlled by the \code{direction} argument)
\item coloring method: \code{data_color()} automatically computes colors based on the
column type but you can choose a specific methodology (e.g., with bins or
quantiles) and the function will generate colors accordingly; the \code{method}
argument controls this through keywords and other arguments act as inputs to
specific methods
\item coloring function: a custom function can be supplied to the \code{fn} argument
for finer control over color evaluation with data; the color mapping
\verb{col_*()} functions in the \strong{scales} package can be used here or any
function you might want to define
\item color palettes: with \code{palette} we could supply a vector of colors, a
\strong{virdis} or \strong{RColorBrewer} palette name, or, a palette from the
\strong{paleteer} package
\item value domain: we can either opt to have the range of values define the
domain, or, specify one explicitly with the \code{domain} argument
\item indirect color application: it's possible to compute colors from one column
and apply them to one or more different columns; we can even perform a
color mapping from multiple source columns to the same multiple of target
columns
\item color application: with the \code{apply_to} argument, there's an option for
whether to apply the cell-specific colors to the cell background or the cell
text
\item text autocoloring: if colorizing the cell background, \code{data_color()} will
automatically recolor the foreground text to provide the best contrast (can
be deactivated with \code{autocolor_text = FALSE})
}

The \code{data_color()} function won't fail with the default options used, but
that won't typically provide you the type of colorization you really need.
You can however safely iterate through a collection of different options
without running into too many errors.
}
\section{Easy color palette access from \strong{paletteer}}{


Choosing the right color palette can often be difficult because it's both
hard to discover suitable palettes and then obtain the vector of colors. To
make this process easier we can elect to use the \strong{paletteer} package,
which makes a wide range of palettes from various R packages readily
available. The \code{\link[=info_paletteer]{info_paletteer()}} information table allows us to easily
inspect all of the discrete color palettes available in \strong{paletteer}. We
only then need to specify the \code{package} and \code{palette} when calling the
\code{\link[paletteer:paletteer_d]{paletteer::paletteer_d()}} function, and, we get the palette as a vector of
hexadecimal colors.
}

\section{Foreground text and background fill}{


By default, \strong{gt} will choose the ideal text color (for maximal contrast)
when colorizing the background of data cells. This option can be disabled by
setting \code{autocolor_text} to \code{FALSE}.
}

\section{Color mapping functions from \strong{scales}}{


The \verb{col_*()} color mapping functions from the \strong{scales} package can be used
in the \code{fn} argument. These functions map data values (\code{numeric} or
\code{factor}/\code{character}) to colors according to the provided palette.

\itemize{
\item \code{\link[scales:col_numeric]{scales::col_numeric()}}: provides a simple linear mapping from
continuous numeric data to an interpolated palette.
\item \code{\link[scales:col_numeric]{scales::col_bin()}}: provides a mapping of continuous numeric data to
value-based bins. This internally uses the \code{\link[base:cut]{base::cut()}} function.
\item \code{\link[scales:col_numeric]{scales::col_quantile()}}: provides a mapping of continuous
numeric data to quantiles. This internally uses the
\code{\link[stats:quantile]{stats::quantile()}} function.
\item \code{\link[scales:col_numeric]{scales::col_factor()}}: provides a mapping of factors to colors. If the
palette is discrete and has a different number of colors than the number of
factors, interpolation is used.
}
}

\section{Examples}{


The \code{data_color()} function can be used without any supplied arguments to
colorize a \strong{gt} table. Let's do this with the \code{\link{exibble}} dataset:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{exibble \%>\%
  gt() \%>\%
  data_color()
}\if{html}{\out{</div>}}

\if{html}{\out{
<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_1.png" alt="This image of a table was generated from the first code example in the `data_color()` help file." style="width:100\%;">
}}

What's happened is that \code{data_color()} applies background colors to all cells
of every column with the default palette in R (accessed through \code{palette()}).
The default method for applying color is \code{"auto"}, where numeric values will
use the \code{"numeric"} method and character or factor values will use the
\code{"factor"} method. The text color will be undergo modification automatically
to maximize contrast (since \code{autocolor_text} is \code{TRUE} by default).

You can one of several methods and \strong{gt} will only apply color to the
compatible values. Let's use the \code{"numeric"} method and supply \code{palette}
values of \code{"red"} and \code{"green"}.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{exibble \%>\%
  gt() \%>\%
  data_color(
    method = "numeric",
    palette = c("red", "green")
  )
}\if{html}{\out{</div>}}

\if{html}{\out{
<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_2.png" alt="This image of a table was generated from the second code example in the `data_color()` help file." style="width:100\%;">
}}

With those options in place we see that only the numeric columns \code{num} and
\code{currency} received color treatments. Moreover, the palette colors were
mapped to the lower and upper limits of the data in each column; interpolated
colors were used for the values in between the numeric limits of the two
columns.

We can constrain the cells to which coloring will be applied with the
\code{columns} and \code{rows} arguments. Further to this, we can manually set the
limits of the data with the \code{domain} argument (which is preferable in most
cases). Here, the domain will be set as \code{domain = c(0, 50)}.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{exibble \%>\%
  gt() \%>\%
  data_color(
    columns = currency,
    rows = currency < 50,
    method = "numeric",
    palette = c("red", "green"),
    domain = c(0, 50)
  )
}\if{html}{\out{</div>}}

\if{html}{\out{
<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_3.png" alt="This image of a table was generated from the third code example in the `data_color()` help file." style="width:100\%;">
}}

We can use any of the \strong{RColorBrewer} and \strong{viridis} palettes. Let's make a
new \strong{gt} table from a subset of the \code{\link{countrypops}} dataset. Then, through
\code{data_color()}, we'll apply coloring to the \code{population} column with the
\code{"numeric"} method, use a domain between 2.5 and 3.2 million, and specify
\code{palette = "viridis"}.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{countrypops \%>\%
  dplyr::filter(country_name == "Mongolia") \%>\%
  dplyr::select(-contains("code")) \%>\%
  tail(10) \%>\%
  gt() \%>\%
  data_color(
    columns = population,
    method = "numeric",
    palette = "viridis",
    domain = c(2.5E6, 3.2E6)
  )
}\if{html}{\out{</div>}}

\if{html}{\out{
<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_4.png" alt="This image of a table was generated from the fourth code example in the `data_color()` help file." style="width:100\%;">
}}

We can alternatively use the \code{fn} for supplying the \strong{scales}-based function
\code{\link[scales:col_numeric]{scales::col_numeric()}}. That function call will return a function (which is
what the \code{fn} argument requires) that takes a vector of numeric values and
returns color values. Here is the more complex version of the code that
returns the same table as in the previous example.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{countrypops \%>\%
  dplyr::filter(country_name == "Mongolia") \%>\%
  dplyr::select(-contains("code")) \%>\%
  tail(10) \%>\%
  gt() \%>\%
  data_color(
    columns = population,
    fn = scales::col_numeric(
      palette = "viridis",
      domain = c(2.5E6, 3.2E6)
    )
  )
}\if{html}{\out{</div>}}

\if{html}{\out{
<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_4.png" alt="This image of a table was generated from the fourth code example in the `data_color()` help file." style="width:100\%;">
}}

Using your own function in \code{fn} can be very useful if you want to make use of
specialized arguments in the \strong{scales} \verb{col_*()} functions. You could even
supply your own specialized function for performing complex colorizing
treatments!

The \code{data_color()} function has a way to apply colorization indirectly to
other columns. That is, you can apply colors to a column different from the
one used to generate those specific colors. The trick is to use the
\code{target_columns} argument. Let's do this with a more complete
\code{\link{countrypops}}-based table example.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{countrypops \%>\%
  dplyr::filter(country_code_3 \%in\% c("FRA", "GBR")) \%>\%
  dplyr::filter(year \%\% 10 == 0) \%>\%
  dplyr::select(-contains("code")) \%>\%
  dplyr::mutate(color = "") \%>\%
  gt(groupname_col = "country_name") \%>\%
  fmt_integer(columns = population) \%>\%
  data_color(
    columns = population,
    target_columns = color,
    method = "numeric",
    palette = "viridis",
    domain = c(4E7, 7E7)
  ) \%>\%
  cols_label(
    year = "",
    population = "Population",
    color = ""
  ) \%>\%
  opt_vertical_padding(scale = 0.65)
}\if{html}{\out{</div>}}

\if{html}{\out{
<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_5.png" alt="This image of a table was generated from the fifth code example in the `data_color()` help file." style="width:100\%;">
}}

Use \code{\link{pizzaplace}} to create a \strong{gt} table. Apply colors from the
\code{"ggsci::red_material"} palette (it's in the \strong{ggsci} R package but more
easily gotten from the \strong{paletteer} package, info at \code{\link[=info_paletteer]{info_paletteer()}}) to
to \code{sold} and \code{income} columns. Not setting the \code{domain} value will use the
bounds of the available data in each column as the domain.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{pizzaplace \%>\%
  dplyr::group_by(type, size) \%>\%
  dplyr::summarize(
    sold = dplyr::n(),
    income = sum(price),
    .groups = "drop_last"
  ) \%>\%
  dplyr::group_by(type) \%>\%
  dplyr::mutate(f_sold = sold / sum(sold)) \%>\%
  dplyr::mutate(size = factor(
    size, levels = c("S", "M", "L", "XL", "XXL"))
  ) \%>\%
  dplyr::arrange(type, size) \%>\%
  gt(
    rowname_col = "size",
    groupname_col = "type"
  ) \%>\%
  fmt_percent(
    columns = f_sold,
    decimals = 1
  ) \%>\%
  cols_merge(
    columns = c(size, f_sold),
    pattern = "\{1\} (\{2\})"
  ) \%>\%
  cols_align(align = "left", columns = stub()) \%>\%
  data_color(
    columns = c(sold, income),
    method = "numeric",
    palette = "ggsci::red_material"
  )
}\if{html}{\out{</div>}}

\if{html}{\out{
<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_data_color_6.png" alt="This image of a table was generated from the sixth code example in the `data_color()` help file." style="width:100\%;">
}}
}

\section{Function ID}{

3-23
}

\seealso{
Other data formatting functions: 
\code{\link{fmt_bytes}()},
\code{\link{fmt_currency}()},
\code{\link{fmt_datetime}()},
\code{\link{fmt_date}()},
\code{\link{fmt_duration}()},
\code{\link{fmt_engineering}()},
\code{\link{fmt_fraction}()},
\code{\link{fmt_integer}()},
\code{\link{fmt_markdown}()},
\code{\link{fmt_number}()},
\code{\link{fmt_partsper}()},
\code{\link{fmt_passthrough}()},
\code{\link{fmt_percent}()},
\code{\link{fmt_roman}()},
\code{\link{fmt_scientific}()},
\code{\link{fmt_time}()},
\code{\link{fmt}()},
\code{\link{sub_large_vals}()},
\code{\link{sub_missing}()},
\code{\link{sub_small_vals}()},
\code{\link{sub_values}()},
\code{\link{sub_zero}()},
\code{\link{text_transform}()}
}
\concept{data formatting functions}
