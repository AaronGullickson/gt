% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modify_columns.R
\name{cols_nanoplot}
\alias{cols_nanoplot}
\title{Add a new column of nanoplots, taking input data from selected columns}
\usage{
cols_nanoplot(
  data,
  columns,
  rows = everything(),
  plot_type = c("line", "bar"),
  missing_vals = c("gap", "zero", "remove"),
  columns_x = NULL,
  reference_line = NULL,
  reference_area = NULL,
  new_col_name = NULL,
  new_col_label = NULL,
  before = NULL,
  after = NULL,
  height = NULL,
  options = NULL
)
}
\arguments{
\item{data}{\emph{The gt table data object}

\verb{obj:<gt_tbl>} // \strong{required}

This is the \strong{gt} table object that is commonly created through use of the
\code{\link[=gt]{gt()}} function.}

\item{columns}{\emph{Columns from which to get data for the dependent variable}

\verb{<column-targeting expression>} // \strong{required}

The columns which contain the numeric data to be plotted as nanoplots. Can
either be a series of column names provided in \code{\link[=c]{c()}}, a vector of column
indices, or a select helper function. Examples of select helper functions
include \code{\link[=starts_with]{starts_with()}}, \code{\link[=ends_with]{ends_with()}}, \code{\link[=contains]{contains()}}, \code{\link[=matches]{matches()}},
\code{\link[=one_of]{one_of()}}, \code{\link[=num_range]{num_range()}}, and \code{\link[=everything]{everything()}}. Data collected from the
columns will be concatenated together in the order of resolution.}

\item{rows}{\emph{Rows that should contain nanoplots}

\verb{<row-targeting expression>} // \emph{default:} \code{everything()}

With \code{rows} we can specify which rows should contain nanoplots in the new
column. The default \code{\link[=everything]{everything()}} results in all rows in \code{columns} being
formatted. Alternatively, we can supply a vector of row captions within
\code{\link[=c]{c()}}, a vector of row indices, or a select helper function. Examples of
select helper functions include \code{\link[=starts_with]{starts_with()}}, \code{\link[=ends_with]{ends_with()}},
\code{\link[=contains]{contains()}}, \code{\link[=matches]{matches()}}, \code{\link[=one_of]{one_of()}}, \code{\link[=num_range]{num_range()}}, and \code{\link[=everything]{everything()}}.
We can also use expressions to filter down to the rows we need (e.g.,
\verb{[colname_1] > 100 & [colname_2] < 50}).}

\item{plot_type}{\emph{The type of nanoplot to display}

\verb{singl-kw:[line|bar]} // \emph{default:} \code{"line"}

Nanoplots can either take the form of a line plot (using \code{"line"}) or a bar
plot (with \code{"bar"}). A line plot, by default, contains layers for a data
line, data points, and a data area. Each of these can be deactivated by
using \code{\link[=nanoplot_options]{nanoplot_options()}}. With a bar plot, the always visible layer is
that of the data bars. Furthermore, a line plot can optionally take in \emph{x}
values through the \code{columns_x} argument whereas a bar plot ignores any data
representing the independant variable.}

\item{missing_vals}{\emph{Treatment of missing values}

\verb{singl-kw:[gap|zero|remove]} // \emph{default:} \code{"gap"}

If missing values are encountered within the input data, there are three
strategies available for their handling: (1) \code{"gap"} will display data gaps
at the sites of missing data, where data lines will have discontinuities;
(2) \code{"zero"} will replace \code{NA} values with zero values; and (3) \code{"remove"}
will remove any incoming \code{NA} values.}

\item{columns_x}{\emph{Columns containing values for the optional x variable}

\verb{<column-targeting expression>} // \emph{default:} \code{NULL} (\code{optional})

We can optionally obtain data for the independent variable (i.e., the
\emph{x}-axis data) if specifying columns in \code{columns_x}. This is only for the
\code{"line"} type of plot (set via the \code{plot_type} argument). We can supply
either be a series of column names provided in \code{\link[=c]{c()}}, a vector of column
indices, or a select helper function. Examples of select helper functions
include \code{\link[=starts_with]{starts_with()}}, \code{\link[=ends_with]{ends_with()}}, \code{\link[=contains]{contains()}}, \code{\link[=matches]{matches()}},
\code{\link[=one_of]{one_of()}}, \code{\link[=num_range]{num_range()}}, and \code{\link[=everything]{everything()}}. Data collected from the
columns will be concatenated together in the order of resolution.}

\item{reference_line}{\emph{Add a reference line}

\verb{scalar<numeric|integer|character>} // \emph{default:} \code{NULL} (\code{optional})

Supplying a single value here will add a horizontal reference line. It
could be a static numeric value, applied to all nanoplots generated. Or,
the input can be one of the following for generating the line from the
underlying data: (1) \code{"mean"}, (2) \code{"median"}, (3) \code{"min"}, (4) \code{"max"},
(5) \code{"first"}, or (6) \code{"last"}.}

\item{reference_area}{\emph{Add a reference area}

\verb{vector<numeric|integer|character>|list} // \emph{default:} \code{NULL} (\code{optional})

A reference area requires two inputs to define bottom and top boundaries
for a rectangular area. The types of values supplied are the same as those
expected for \code{reference_line}, which is either a static numeric value or
one of the following keywords for the generation of the value: (1)
\code{"mean"}, (2) \code{"median"}, (3) \code{"min"}, (4) \code{"max"}, (5) \code{"first"}, or (6)
\code{"last"}. Input can either be a vector or list with two elements.}

\item{new_col_name}{\emph{Column name for the new column containing the plots}

\verb{scalar<character>} // \emph{default:} \code{NULL} (\code{optional})

A single column name in quotation marks. Values will be extracted from this
column and provided to compatible arguments. If not provided the new column
name will be \code{"nanoplots"}.}

\item{new_col_label}{\emph{Column label for the new column containing the plots}

\verb{scalar<character>} // \emph{default:} \code{NULL} (\code{optional})

A single column label. If not supplied then the column label will inherit
from \code{new_col_name} (if nothing provided to that argument, the label will
be \code{"nanoplots"}).}

\item{before, after}{\emph{Column used as anchor}

\verb{<column-targeting expression>} // \emph{default:} \code{NULL} (\code{optional})

A single column-resolving expression or column index can be given to either
\code{before} or \code{after}. The column specifies where the new column containing
the nanoplots should be positioned among the existing columns in the input
data table. While select helper functions such as \code{\link[=starts_with]{starts_with()}} and
\code{\link[=ends_with]{ends_with()}} can be used for column targeting, it's recommended that a
single column name or index be used. This is to ensure that exactly one
column is provided to either of these arguments (otherwise, the function
will be stopped). If nothing is provided for either argument then the new
column will be placed at the end of the column series.}

\item{height}{\emph{The height of the nanoplots}

\verb{scalar<character>} // \emph{default:} \code{NULL} (\code{optional})

The height of the nanoplots. If nothing is provided here then \strong{gt} will
provide a sensible length value of \code{"1.5em"}.}

\item{options}{\emph{Set options for the nanoplots}

\verb{obj:<nanoplot_options} // \emph{default:} \code{NULL} (\code{optional})

By using the \code{\link[=nanoplot_options]{nanoplot_options()}} helper function here, you can alter the
layout and styling of the nanoplots in the new column.}
}
\value{
An object of class \code{gt_tbl}.
}
\description{
Nanoplots are tiny plots you can use in your \strong{gt} table. They are simple by
design, mainly because there isn't a lot of space to work with. With that
simplicity, however, you do get a set of very succinct data visualizations
that adapt nicely to the amount of data you feed into them. With
\code{cols_nanoplot()} you take data from one or more columns as the basic inputs
for the nanoplots and generate a new column containing the plots.

Each nanoplot contains data points with reasonably good visibility, having
smooth connecting lines between them to allow for easier scanning of values.
By default, a nanoplot will have basic interactivity. One can hover over the
data points and vertical guides will display values ascribed to each. A
horizontal \emph{reference line} is also present in the standard view (denoting
the median of the data). This reference line can be customized by providing a
static value or by choosing a keyword that computes a particular \emph{y} value
using a nanoplot's data values. Aside from a reference line, there is also an
associated \emph{reference area} which, by default, tries to make itself useful by
bounding the area between the lower and upper quartiles of the data. These
boundaries can also be customized in a similar fashion as the reference line.
The nanoplots are robust against missing values, and multiple strategies are
available for handling missingness.

While basic customization options are present in the \code{cols_nanoplot()}, many
more opportunities for customizing nanoplots on a more granular level are
possible with the \code{\link[=nanoplot_options]{nanoplot_options()}} helper function. That is to be
invoked at the \code{options} argument of \code{cols_nanoplot()}. Through that helper
function, layers of the nanoplots can be selectively removed and aesthetics
of the remaining plot components can modified.
}
\section{Targeting cells with \code{columns} and \code{rows}}{


Targeting of values to insert into the nanoplots is done through \code{columns}
and additionally by \code{rows} (if nothing is provided for \code{rows} then entire
columns are selected). Aside from declaring column names in \code{c()} (with bare
column names or names in quotes) we can use also
\strong{tidyselect}-style expressions. This can be as basic as supplying a select
helper like \code{starts_with()}, or, providing a more complex incantation like

\code{where(~ is.numeric(.x) && max(.x, na.rm = TRUE) > 1E6)}

which targets numeric columns that have a maximum value greater than
1,000,000 (excluding any \code{NA}s from consideration).

Once the columns are targeted, we may also target the \code{rows} within those
columns. This can be done in a variety of ways. If a stub is present, then we
potentially have row identifiers. Those can be used much like column names in
the \code{columns}-targeting scenario. We can use simpler \strong{tidyselect}-style
expressions (the select helpers should work well here) and we can use quoted
row identifiers in \code{c()}. It's also possible to use row indices (e.g.,
\code{c(3, 5, 6)}) though these index values must correspond to the row numbers of
the input data (the indices won't necessarily match those of rearranged rows
if row groups are present). One more type of expression is possible, an
expression that takes column values (can involve any of the available columns
in the table) and returns a logical vector.
}

\section{Examples}{


Let's make some nanoplots with the \code{\link{illness}} dataset. The columns beginning
with 'day' all contain ordered measurement values, comprising seven
individual daily results. Using \code{cols_nanoplot()} we create a new column to
hold the nanoplots (with \code{new_col_name = "nanoplots"}), referencing the
columns containing the data (with \code{columns = starts_with("day")}). It's also
possible to define a column label here using the \code{new_col_label} argument.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{illness |>
  dplyr::slice_head(n = 10) |>
  gt(rowname_col = "test") |>
  tab_header("Partial summary of daily tests performed on YF patient") |>
  tab_stubhead(label = md("**Test**")) |>
  cols_hide(columns = c(starts_with("norm"), starts_with("day"))) |>
  fmt_units(columns = units) |>
  cols_nanoplot(
    columns = starts_with("day"),
    new_col_name = "nanoplots",
    new_col_label = md("*Progression*"),
    options = nanoplot_options(
      show_reference_line = FALSE,
      show_reference_area = FALSE
    )
  ) |>
  cols_align(align = "center", columns = nanoplots) |>
  cols_merge(columns = c(test, units), pattern = "\{1\} (\{2\})") |>
  tab_footnote(
    footnote = "Measurements from Day 3 through to Day 8.",
    locations = cells_column_labels(columns = nanoplots)
  )
}\if{html}{\out{</div>}}

\if{html}{\out{
<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cols_nanoplot_1.png" alt="This image of a table was generated from the first code example in the `cols_nanoplot()` help file." style="width:100\%;">
}}

Now we'll make another table that contains two columns of nanoplots. Starting
from the \code{\link{towny}} dataset, we first reduce it down to a subset of columns
and rows. All of the columns related to either population or density will be
used as input data for the two nanoplots. Both nanoplots will use a reference
line that is generated from the median of the input data. And by naming the
new nanoplot-laden columns in a similar manner as the input data columns, we
can take advantage of select helpers (e.g., when using \code{\link[=tab_spanner]{tab_spanner()}}). Many
of the input data columns are now redundant because of the plots, so we'll
elect to hide most of those with \code{\link[=cols_hide]{cols_hide()}}.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{towny |>
  dplyr::select(name, starts_with("population"), starts_with("density")) |>
  dplyr::filter(population_2021 > 200000) |>
  dplyr::arrange(desc(population_2021)) |>
  gt() |>
  fmt_integer(columns = starts_with("population")) |>
  fmt_number(columns = starts_with("density"), decimals = 1) |>
  cols_nanoplot(
    columns = starts_with("population"),
    reference_line = "median",
    reference_area = NA,
    new_col_name = "population_plot",
    new_col_label = md("*Change*")
  ) |>
  cols_nanoplot(
    columns = starts_with("density"),
    reference_line = "median",
    reference_area = NA,
    new_col_name = "density_plot",
    new_col_label = md("*Change*")
  ) |>
  cols_hide(columns = matches("2001|2006|2011|2016")) |>
  tab_spanner(
    label = "Population",
    columns = starts_with("population")
  ) |>
  tab_spanner(
    label = "Density (\{\{*persons* km^-2\}\})",
    columns = starts_with("density")
  ) |>
  cols_label_with(
    columns = -matches("plot"),
    fn = function(x) gsub("\\\\D+", "", x)
  ) |>
  cols_align(align = "center", columns = matches("plot")) |>
  cols_width(
    name ~ px(140),
    everything() ~ px(100)
  ) |>
  opt_horizontal_padding(scale = 2)
}\if{html}{\out{</div>}}

\if{html}{\out{
<img src="https://raw.githubusercontent.com/rstudio/gt/master/images/man_cols_nanoplot_2.png" alt="This image of a table was generated from the second code example in the `cols_nanoplot()` help file." style="width:100\%;">
}}
}

\section{Function ID}{

5-8
}

\section{Function Introduced}{

\emph{In Development}
}

\seealso{
Other column modification functions: 
\code{\link{cols_add}()},
\code{\link{cols_align_decimal}()},
\code{\link{cols_align}()},
\code{\link{cols_hide}()},
\code{\link{cols_label_with}()},
\code{\link{cols_label}()},
\code{\link{cols_merge_n_pct}()},
\code{\link{cols_merge_range}()},
\code{\link{cols_merge_uncert}()},
\code{\link{cols_merge}()},
\code{\link{cols_move_to_end}()},
\code{\link{cols_move_to_start}()},
\code{\link{cols_move}()},
\code{\link{cols_unhide}()},
\code{\link{cols_units}()},
\code{\link{cols_width}()}
}
\concept{column modification functions}
